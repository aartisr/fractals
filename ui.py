"""
Fractal Workspace UI
===================

This application provides a graphical user interface (GUI) for generating, visualizing, and analyzing fractals.

Features:
- Generate and customize various fractal types (Mandelbrot, Julia, Burning Ship, Newton, Barnsley Fern, Sierpinski Triangle)
- Save generated fractal images
- Take notes and view fractal dimension formulas
- Perform box counting (fractal dimension estimation) on regions of interest (ROI) in images

Instructions:
1. Run this script to launch the Fractal Workspace.
2. Use the tabs to switch between Fractal Generator, Fractal Box Counting, and Box Counter tools.
3. In the Fractal Generator tab, select a fractal type, adjust parameters, and click 'Generate Fractal'.
4. In the Box Counter tab, load an image, set ROI size, and click on the image to compute the fractal dimension of the selected region.
5. Use the Save button to export fractal images.

Requirements:
- Python 3.7+
- PyQt6
- OpenCV (cv2)
- NumPy
- Matplotlib
- scikit-image
"""

from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    QWidget,
    QGridLayout,
    QFileDialog,
    QPushButton,
    QComboBox,
    QMessageBox,
    QLineEdit,
    QLabel,
    QProgressBar,
    QSizePolicy,
    QTabWidget,
    QFrame,
    QVBoxLayout,
    QSpacerItem,
)
from PyQt6.QtCore import Qt
import sys
import cv2
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg
import threading
import queue
import time
from fractals import (
    Mandelbrot,
    Julia,
    BurningShip,
    NewtonFractal,
    BarnsleyFern,
    SierpinskiTriangle,
)
from PyQt6.QtGui import QImage, QPixmap

# Import ROIImageLabel and BoxCounterUtils from the new modules
from boxcounting.roi_image_label import ROIImageLabel
from boxcounting.box_counter_helpers import BoxCounterHelpers

matplotlib.use("QtAgg")


class MainWindow(QMainWindow):
    def get_fractal_info(self, fractal_type):
        """
        Return verbose information and formula for the selected fractal type.
        """
        if fractal_type == "Mandelbrot":
            return (
                "<h3>Mandelbrot Set</h3>"
                "<p>The Mandelbrot set is a set of complex numbers c for which the sequence defined by <b>z<sub>n+1</sub> = z<sub>n</sub><sup>p</sup> + c</b> (with z<sub>0</sub> = 0) does not diverge to infinity. The boundary of the Mandelbrot set is a fractal.</p>"
                "<b>Formula:</b> <br>"
                "<div style='text-align:center;font-size:16px;'>z<sub>n+1</sub> = z<sub>n</sub><sup>p</sup> + c</div>"
                "<ul><li>p: Power (usually 2)</li><li>c: Complex parameter (varies per pixel)</li></ul>"
                "<p>The fractal dimension of the Mandelbrot set boundary is approximately 2.</p>"
            )
        elif fractal_type == "Julia":
            return (
                "<h3>Julia Set</h3>"
                "<p>Julia sets are generated by iterating <b>z<sub>n+1</sub> = z<sub>n</sub><sup>p</sup> + c</b> for each point z<sub>0</sub> in the complex plane, with a fixed complex constant c. The resulting set of points that do not escape to infinity forms the Julia set.</p>"
                "<b>Formula:</b> <br>"
                "<div style='text-align:center;font-size:16px;'>z<sub>n+1</sub> = z<sub>n</sub><sup>p</sup> + c</div>"
                "<ul><li>p: Power (usually 2)</li><li>c: Complex constant (user-defined)</li></ul>"
                "<p>Julia sets can have non-integer fractal dimensions, typically between 1 and 2.</p>"
            )
        elif fractal_type == "Burning Ship":
            return (
                "<h3>Burning Ship Fractal</h3>"
                "<p>The Burning Ship fractal is defined by iterating <b>z<sub>n+1</sub> = (|Re(z<sub>n</sub>)| + i|Im(z<sub>n</sub>)|)<sup>p</sup> + c</b> with z<sub>0</sub> = 0. The absolute values create the characteristic 'ship' shape.</p>"
                "<b>Formula:</b> <br>"
                "<div style='text-align:center;font-size:16px;'>z<sub>n+1</sub> = (|Re(z<sub>n</sub>)| + i|Im(z<sub>n</sub>)|)<sup>p</sup> + c</div>"
                "<ul><li>p: Power (usually 2)</li><li>c: Complex parameter (varies per pixel)</li></ul>"
                "<p>The fractal dimension is estimated to be about 2.</p>"
            )
        elif fractal_type == "Newton":
            return (
                "<h3>Newton Fractal</h3>"
                "<p>The Newton fractal visualizes the basins of attraction for Newton's method applied to a polynomial equation. For a function f(z), the iteration is <b>z<sub>n+1</sub> = z<sub>n</sub> - f(z<sub>n</sub>)/f'(z<sub>n</sub>)</b>.</p>"
                "<b>Formula:</b> <br>"
                "<div style='text-align:center;font-size:16px;'>z<sub>n+1</sub> = z<sub>n</sub> - \frac{f(z<sub>n</sub>)}{f'(z<sub>n</sub>)}</div>"
                "<ul><li>f(z): Polynomial (e.g., z<sup>3</sup> - 1)</li></ul>"
                "<p>The fractal dimension depends on the polynomial and is typically between 1.5 and 2.</p>"
            )
        elif fractal_type == "Barnsley Fern":
            return (
                "<h3>Barnsley Fern</h3>"
                "<p>The Barnsley Fern is a fractal constructed using an iterated function system (IFS) of affine transformations. It visually resembles a natural fern leaf.</p>"
                "<b>Affine Transformations:</b> <br>"
                "<div style='font-size:14px;'>"
                "x<sub>n+1</sub> = a<sub>i</sub>x<sub>n</sub> + b<sub>i</sub>y<sub>n</sub> + e<sub>i</sub><br>"
                "y<sub>n+1</sub> = c<sub>i</sub>x<sub>n</sub> + d<sub>i</sub>y<sub>n</sub> + f<sub>i</sub>"
                "</div>"
                "<p>Each transformation is chosen with a certain probability.</p>"
                "<p>The fractal dimension of the Barnsley Fern is about 1.67.</p>"
            )
        elif fractal_type == "Sierpinski Triangle":
            return (
                "<div style='background:#eaf3fa; border-radius:10px; padding:12px 18px 10px 18px; margin-bottom:8px;'>"
                "<h3 style='color:#1976d2; margin-top:0;'>Sierpinski Triangle</h3>"
                "<p style='font-size:15px; color:#0a2342;'>The Sierpinski Triangle is a self-similar fractal constructed by recursively removing the central triangle from a larger equilateral triangle.</p>"
                "<div style='background:#fffbe7; border:1.5px solid #f7d774; border-radius:8px; padding:10px 14px; margin:10px 0 10px 0;'>"
                "<b style='color:#b8860b; font-size:16px;'>Fractal Dimension:</b><br>"
                "<span style='font-size:20px; color:#b8860b;'>D = log(3) / log(2) &asymp; 1.585</span>"
                "</div>"
                "<p style='font-size:14.5px; color:#0a2342; margin-bottom:0;'>It is a classic example of a deterministic fractal.</p>"
                "</div>"
            )
        else:
            return (
                "<h3>Fractal Information</h3>"
                "<p>Select a fractal type to see detailed information and the mathematical formula here.</p>"
            )

    @staticmethod
    def np_to_pixmap(arr):
        if arr.dtype != np.uint8:
            arr = arr.astype(np.uint8)
        if arr.ndim == 2:
            # Grayscale
            h, w = arr.shape
            qimg = QImage(arr.data, w, h, w, QImage.Format.Format_Grayscale8)
        else:
            h, w, ch = arr.shape
            if ch == 3:
                qimg = QImage(arr.data, w, h, ch * w, QImage.Format.Format_RGB888)
            elif ch == 4:
                qimg = QImage(arr.data, w, h, ch * w, QImage.Format.Format_RGBA8888)
            else:
                raise ValueError("Unsupported channel count for np_to_pixmap")
        return QPixmap.fromImage(qimg)

    def show_boxcount_comparison(self, img1, img2):
        import matplotlib.pyplot as plt
        import tempfile
        import os
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QHBoxLayout
        from PyQt6.QtGui import QPixmap, QImage
        import cv2
        import numpy as np

        # Preprocess: grayscale, binarize
        def preprocess(img):
            if img.ndim == 3:
                img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
            _, binary = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            return binary

        img1_bin = preprocess(img1)
        img2_bin = preprocess(img2)

        # Step 1: Show original and binarized images
        dialog = QDialog(self)
        dialog.setWindowTitle("Box Counting Comparison: Stepwise Analysis")
        layout = QVBoxLayout()

        # Step 2: Overlay grids and count boxes for each size
        box_sizes = [32, 16, 8]
        overlays1, overlays2 = [], []
        counts1, counts2 = [], []
        for size in box_sizes:

            def overlay_grid(img, box_size):
                img_rgb = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
                h, w = img.shape
                for x in range(0, w, box_size):
                    cv2.line(img_rgb, (x, 0), (x, h), (0, 0, 255), 1)
                for y in range(0, h, box_size):
                    cv2.line(img_rgb, (0, y), (w, y), (0, 0, 255), 1)
                return img_rgb

            overlays1.append(overlay_grid(img1_bin, size))
            overlays2.append(overlay_grid(img2_bin, size))
            # Count boxes
            c1 = sum(
                np.any(img1_bin[x: x + size, y: y + size])
                for x in range(0, img1_bin.shape[0], size)
                for y in range(0, img1_bin.shape[1], size)
            )
            c2 = sum(
                np.any(img2_bin[x: x + size, y: y + size])
                for x in range(0, img2_bin.shape[0], size)
                for y in range(0, img2_bin.shape[1], size)
            )
            counts1.append(c1)
            counts2.append(c2)

        # Step 3: Log-log plot
        log_sizes = np.log(1 / np.array(box_sizes))
        log_counts1 = np.log(counts1)
        log_counts2 = np.log(counts2)
        plt.figure(figsize=(4, 3))
        plt.plot(log_sizes, log_counts1, "o-b", label="Image 1")
        plt.plot(log_sizes, log_counts2, "o-r", label="Image 2")
        plt.xlabel("log(1/Œµ)")
        plt.ylabel("log N(Œµ)")
        plt.title("Box Counting Log-Log Plot")
        plt.legend()
        tmp_plot = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
        plt.tight_layout()
        plt.savefig(tmp_plot.name)
        plt.close()

        # Step 4: Show all steps side by side
        for i, size in enumerate(box_sizes):
            row = QHBoxLayout()
            for img, label in zip([overlays1[i], overlays2[i]], ["Image 1", "Image 2"]):
                qimg = QImage(
                    img.data,
                    img.shape[1],
                    img.shape[0],
                    img.strides[0],
                    QImage.Format.Format_RGB888,
                )
                pixmap = QPixmap.fromImage(qimg)
                lbl = QLabel()
                lbl.setPixmap(pixmap)
                lbl.setFixedSize(200, 200)
                lbl.setScaledContents(True)
                row.addWidget(lbl)
            layout.addLayout(row)
        # Add log-log plot
        plot_lbl = QLabel()
        plot_pixmap = QPixmap(tmp_plot.name)
        plot_lbl.setPixmap(plot_pixmap)
        plot_lbl.setFixedSize(300, 220)
        plot_lbl.setScaledContents(True)
        layout.addWidget(plot_lbl)

        # Add summary
        summary = QLabel(
            f"Box sizes: {box_sizes}\nImage 1 counts: {counts1}\nImage 2 counts: {counts2}"
        )
        layout.addWidget(summary)

        dialog.setLayout(layout)
        dialog.exec()
        os.unlink(tmp_plot.name)

    """
    Main window for the Fractal Workspace application.
    Provides tabs for fractal generation, wiki, and box counting.
    """

    def __init__(self):
        """
        Initialize the main window and set up all tabs and UI components.
        """
        super().__init__()
        self.setWindowTitle("Fractal Workspace")
        # self.resize(640, 800)
        self.resize(1200, 800)

        # Create a QTabWidget
        self.tabs = QTabWidget()

        # Create the first tab (Fractal Generator)
        self.fractal_tab = QWidget()
        self.setup_fractal_tab()
        self.tabs.addTab(self.fractal_tab, "Fractal Generator")

        # Create second tab (Fractal Box Counter)
        self.box_counter_tab = QWidget()
        self.setup_box_counter_tab()
        self.tabs.addTab(self.box_counter_tab, "Box Counter")

        # Create third tab (Image Comparison)
        self.image_compare_tab = QWidget()
        self.setup_image_compare_tab()
        self.tabs.addTab(self.image_compare_tab, "Image Compare")

        # Create last tab (Wiki)
        self.wiki_tab = QWidget()
        self.setup_wiki_tab()
        self.tabs.addTab(self.wiki_tab, "Wiki")

        # Set the QTabWidget as the central widget
        self.setCentralWidget(self.tabs)

    def setup_image_compare_tab(self):
        from PyQt6.QtWidgets import QHBoxLayout, QVBoxLayout

        layout = QVBoxLayout()
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(4)

        # Professional header and process button
        header_row = QHBoxLayout()
        header = QLabel(
            """
            <div style='display:flex;align-items:center;'>
                <span style='font-size:26px; font-weight:bold; color:#234; letter-spacing:0.5px;'>üñºÔ∏è Image Comparison</span>
                <span style='font-size:15px; color:#357; margin-left:18px;'>Box Counting Fractal Analysis</span>
            </div>
        """
        )
        header.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        header.setStyleSheet(
            "background:#eaf3fa; color:#234; border-radius:14px; padding:18px 0 12px 24px; margin-bottom:8px; font-size:22px; font-weight:bold; box-shadow: 0 2px 8px #e0eaf5;"
        )
        header_row.addWidget(header, stretch=1)
        self.process_btn = QPushButton("Process")
        self.process_btn.setEnabled(False)
        self.process_btn.setStyleSheet(
            "QPushButton { font-size: 13pt; padding: 10px 32px; border-radius: 10px; background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #43a047, stop:1 #1976d2); color: white; font-weight: bold; margin-top: 0px; margin-bottom: 0px; } "
            "QPushButton:disabled { background: #b7c7b7; color: #f0f0f0; } "
            "QPushButton:hover:!disabled { background: #388e3c; }"
        )
        self.process_btn.setToolTip(
            "Run box counting comparison when both images are loaded."
        )
        header_row.addWidget(self.process_btn, alignment=Qt.AlignmentFlag.AlignRight)
        layout.addLayout(header_row)

        # Professional instructions
        instructions = QLabel(
            """
        <div style='font-size:12.5pt; color:#234; background:#f7fbff; border-radius:12px; padding:16px 24px; margin-bottom:10px; border:1.5px solid #e0eaf5;'>
        <b>How to use:</b><br>
        <ol style='margin:0 0 0 18px;padding:0;font-size:12pt;'>
        <li><b>Select or drag-and-drop</b> two images below.</li>
        <li>The tool will preprocess, binarize, and analyze both images using the <b>box counting method</b>.</li>
        <li>Stepwise results include preprocessing, box counting, log-log plot, and fractal dimension estimation.</li>
        </ol>
        <span style='color:#1976d2;'><b>Tip:</b></span> For best results, use high-contrast, binarized images of similar scale.<br>
        </div>
        """
        )
        instructions.setWordWrap(True)
        instructions.setAlignment(
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter
        )
        instructions.setStyleSheet(
            "background:#f7fbff; border-radius:12px; padding:0; margin-bottom:8px; color:#2d4157; border:1.5px solid #e0eaf5;"
        )
        layout.addWidget(instructions)

        # Image drop areas with modern styling, compact spacing
        img_layout = QHBoxLayout()
        img_layout.setSpacing(16)
        img_layout.addStretch(1)
        for idx in [1, 2]:
            label = QLabel(
                f"<b style='color:{'#1976d2' if idx==1 else '#d32f2f'};'>Image {idx}</b><br><span style='font-size:11pt;color:#5a6a7a'>(Double-click or drop image)</span>"
            )
            label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            label.setMinimumSize(340, 340)
            label.setMaximumSize(500, 500)
            label.setStyleSheet(
                f"border: 2.5px dashed #7da0c4; border-radius: 18px; background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #f7fbff, stop:1 #e3eaf2); font-size: 13pt; color: {'#1976d2' if idx==1 else '#d32f2f'}; transition: box-shadow 0.2s;"
            )
            label.setToolTip(
                f"Double-click or drop an image to load Image {idx} for comparison."
            )
            # Add hover effect for drop area
            label.setProperty("class", "image-drop-area")
            if idx == 1:
                self.img1_label = label
                self.img1_label.mouseDoubleClickEvent = (
                    lambda event: self.handle_image_label_double_click(1)
                )
                img_layout.addWidget(self.img1_label, stretch=1)
            else:
                self.img2_label = label
                self.img2_label.mouseDoubleClickEvent = (
                    lambda event: self.handle_image_label_double_click(2)
                )
                img_layout.addSpacing(24)
                img_layout.addWidget(self.img2_label, stretch=1)
        img_layout.addStretch(1)
        layout.addLayout(img_layout)

        # Updated step-by-step algorithm description
        steps_html = (
            "<b style='font-size:15px;color:#234;'>Box Counting Algorithm Steps:</b><br>"
            "<ol style='margin:0 0 0 18px;padding:0;font-size:12pt;color:#3a4a5d;'>"
            "<li><b>Preprocessing:</b> Convert each image to grayscale and binarize for fair comparison.</li>"
            "<li><b>Overlay Grids:</b> Place square grids of decreasing box sizes over the image.</li>"
            "<li><b>Count Filled Boxes:</b> For each grid size, count boxes containing part of the object.</li>"
            "<li><b>Repeat for Multiple Scales:</b> Analyze at several box sizes to capture structure at different scales.</li>"
            "<li><b>Log-Log Plot:</b> Plot log(box size) vs. log(box count) for all scales.</li>"
            "<li><b>Estimate Fractal Dimension:</b> The slope of the log-log plot estimates the fractal dimension.</li>"
            "</ol>"
        )
        self.boxcount_steps_label = QLabel(steps_html)
        self.boxcount_steps_label.setWordWrap(True)
        self.boxcount_steps_label.setTextFormat(Qt.TextFormat.RichText)
        self.boxcount_steps_label.setAlignment(
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop
        )
        self.boxcount_steps_label.setStyleSheet(
            "font-size: 13pt; color: #234; margin-top: 14px; margin-bottom: 10px; background: #f7fbff; border-radius: 10px; padding: 14px 24px; border:1.5px solid #e0eaf5;"
        )
        layout.addWidget(self.boxcount_steps_label)

        # Remove empty space at the bottom
        layout.addStretch(1)
        self.image_compare_tab.setLayout(layout)

        # Double-click events and process button
        self.img1_label.mouseDoubleClickEvent = (
            lambda event: self.handle_image_label_double_click(1)
        )
        self.img2_label.mouseDoubleClickEvent = (
            lambda event: self.handle_image_label_double_click(2)
        )
        self.process_btn.clicked.connect(self.process_image_compare)

    def handle_image_label_double_click(self, which):
        self.load_image_for_compare(which)
        # Enable process button only if both images are loaded
        img1_loaded = hasattr(self, "_img1_data")
        img2_loaded = hasattr(self, "_img2_data")
        self.process_btn.setEnabled(img1_loaded and img2_loaded)

    def process_image_compare(self):
        # Always use the stored image data to ensure correct mapping
        img1 = getattr(self, "_img1_data", None)
        img2 = getattr(self, "_img2_data", None)
        if img1 is None or img2 is None:
            QMessageBox.warning(
                self, "Image Compare", "Please load both images before processing."
            )
            return
        from boxcounting.box_counter_compare_dialog import (
            show_boxcount_comparison_dialog,
        )

        show_boxcount_comparison_dialog(self, img1, img2, self.np_to_pixmap)

    def get_label_image(self, label):
        pixmap = label.pixmap()
        if pixmap is None:
            return None
        qimg = pixmap.toImage()
        qimg = qimg.convertToFormat(QImage.Format.Format_RGB888)
        width = qimg.width()
        height = qimg.height()
        ptr = qimg.bits()
        ptr.setsize(qimg.sizeInBytes())
        arr = np.frombuffer(ptr, dtype=np.uint8)[: height * width * 3].reshape(
            (height, width, 3)
        )
        return arr

    def load_image_for_compare(self, which):
        from PIL import Image

        fname, _ = QFileDialog.getOpenFileName(
            self,
            "Select Image",
            "",
            "Images (*.png *.jpg *.jpeg *.bmp *.tif *.tiff *.gif)",
        )
        if not fname:
            return
        ext = fname.lower().split(".")[-1]
        try:
            if ext == "gif":
                pil_img = Image.open(fname)
                pil_img = pil_img.convert("RGB")  # Use first frame for static analysis
                img = np.array(pil_img)
            else:
                img = cv2.imread(fname)
                if img is None:
                    raise ValueError("cv2.imread failed")
                img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        except Exception as e:
            QMessageBox.warning(
                self, "Image Compare", f"Failed to load image: {fname}\n{e}"
            )
            return
        # Scale image to fit label
        h, w, _ = img.shape
        scale = min(350 / h, 350 / w)
        new_size = (int(w * scale), int(h * scale))
        img_resized = cv2.resize(img, new_size, interpolation=cv2.INTER_AREA)
        qimg = QImage(
            img_resized.data,
            img_resized.shape[1],
            img_resized.shape[0],
            img_resized.strides[0],
            QImage.Format.Format_RGB888,
        )
        pixmap = QPixmap.fromImage(qimg)
        if which == 1:
            self.img1_label.setPixmap(pixmap)
            self.img1_label.setText("")
            self._img1_data = img  # Store original loaded image
        else:
            self.img2_label.setPixmap(pixmap)
            self.img2_label.setText("")
            self._img2_data = img  # Store original loaded image

    def setup_fractal_tab(self):
        """
        Set up the Fractal Generator tab UI, including controls for fractal type, resolution, color scheme, and parameters.
        Handles all widget creation and layout for the fractal generator.
        """
        # Set the QTabWidget as the central widget

        self.fractal_type = "Mandelbrot"
        self.resolution = "500x500"
        self.color_scheme = "inferno"
        self.max_iter = 100
        self.power = 2.0
        self.c_real = -0.42
        self.c_imag = 0.6
        self.zoom_level = 1.0
        self.fractal_types = [
            "Mandelbrot",
            "Julia",
            "Burning Ship",
            "Newton",
            "Barnsley Fern",
            "Sierpinski Triangle",
        ]
        self.resolutions = [
            "500x500",
            "800x800",
            "1024x1024",
            "1920x1080",
            "2560x1440",
            "3840x2160",
        ]
        self.color_schemes = [
            "inferno",
            "plasma",
            "viridis",
            "magma",
            "twilight",
            "coolwarm",
            "hot",
            "jet",
            "rainbow",
            "terrain",
            "ocean",
            "nipy_spectral",
        ]
        self.progress_value = 0

        layout = QGridLayout()
        layout.setContentsMargins(24, 24, 24, 24)
        layout.setSpacing(18)

        # Add a visually appealing header
        # Add a visually appealing header
        header = QLabel("<b style='font-size:22px;'>‚ú® Fractal Generator</b>")
        header.setStyleSheet(
            "color: #0a2342; background: #eaf3fa; border-radius: 10px; padding: 8px 0 8px 16px; font-weight: bold; letter-spacing: 0.5px;"
        )
        layout.addWidget(header, 0, 0, 1, 2, alignment=Qt.AlignmentFlag.AlignLeft)

        # Add a help/info section
        help_text = QLabel(
            "<span style='color:#3d3d3d;'>Select a fractal type, adjust parameters, and click <b>Generate Fractal</b> to visualize. Save your favorite images or take notes below. Tooltips are available for all controls.</span>"
        )
        help_text.setWordWrap(True)
        help_text.setStyleSheet(
            "font-size: 14px; padding-bottom: 8px; background: #f0f4f8; border-radius: 8px; padding: 10px 16px; color: #0a2342; border: 1.5px solid #b5c7f7;"
        )
        layout.addWidget(help_text, 1, 0, 1, 2)

        # Section background for controls
        controls_frame = QFrame()
        controls_frame.setStyleSheet(
            "background: #f7fafc; border-radius: 14px; border: 1.5px solid #b5c7f7; padding: 20px 20px 14px 20px;"
        )
        controls_layout = QGridLayout()

        # Fractal type selector
        self.fractal_menu_label = QLabel("<b>Fractal Type:</b>")
        self.fractal_menu_label.setStyleSheet("color: #0a2342; font-size: 15px;")
        self.fractal_menu_label.setToolTip("Choose the type of fractal to generate.")
        self.fractal_menu = QComboBox()
        self.fractal_menu.setEditable(False)
        self.fractal_menu.addItems(self.fractal_types)
        self.fractal_menu.setToolTip("Fractal type (e.g., Mandelbrot, Julia, etc.)")
        self.fractal_menu.setAccessibleName("Fractal Type Selector")
        self.fractal_menu.setStyleSheet(
            "QComboBox { background: #fff; border: 1.5px solid #1976d2; border-radius: 7px; padding: 7px 13px; font-size: 15px; color: #0a2342; } QComboBox QAbstractItemView { background: #f7fafc; selection-background-color: #b5c7f7; color: #0a2342; }"
        )
        self.fractal_menu.currentTextChanged.connect(self.combo_frac_type_changed)
        controls_layout.addWidget(self.fractal_menu_label, 0, 0)
        controls_layout.addWidget(self.fractal_menu, 0, 1)

        # Resolution selector
        self.resolution_menu_label = QLabel("<b>Resolution:</b>")
        self.resolution_menu_label.setStyleSheet("color: #0a2342; font-size: 15px;")
        self.resolution_menu_label.setToolTip("Choose the output image resolution.")
        self.resolution_menu = QComboBox()
        self.resolution_menu.setEditable(False)
        self.resolution_menu.addItems(self.resolutions)
        self.resolution_menu.setToolTip("Image resolution for the generated fractal.")
        self.resolution_menu.setAccessibleName("Resolution Selector")
        self.resolution_menu.setStyleSheet(
            "QComboBox { background: #fff; border: 1.5px solid #1976d2; border-radius: 7px; padding: 7px 13px; font-size: 15px; color: #0a2342; } QComboBox QAbstractItemView { background: #f7fafc; selection-background-color: #b5c7f7; color: #0a2342; }"
        )
        self.resolution_menu.currentTextChanged.connect(self.combo_resolution_changed)
        controls_layout.addWidget(self.resolution_menu_label, 1, 0)
        controls_layout.addWidget(self.resolution_menu, 1, 1)

        # Color scheme selector
        self.color_menu_label = QLabel("<b>Color Scheme:</b>")
        self.color_menu_label.setStyleSheet("color: #0a2342; font-size: 15px;")
        self.color_menu_label.setToolTip(
            "Choose the color scheme for the fractal visualization."
        )
        self.color_menu = QComboBox()
        self.color_menu.setEditable(False)
        self.color_menu.addItems(self.color_schemes)
        self.color_menu.setToolTip("Colormap for fractal rendering.")
        self.color_menu.setAccessibleName("Color Scheme Selector")
        self.color_menu.setStyleSheet(
            "QComboBox { background: #fff; border: 1.5px solid #1976d2; border-radius: 7px; padding: 7px 13px; font-size: 15px; color: #0a2342; } QComboBox QAbstractItemView { background: #f7fafc; selection-background-color: #b5c7f7; color: #0a2342; }"
        )
        self.color_menu.currentTextChanged.connect(self.combo_color_scheme_changed)
        controls_layout.addWidget(self.color_menu_label, 2, 0)
        controls_layout.addWidget(self.color_menu, 2, 1)

        self.max_iter_label = QLabel("<b>Max Iterations:</b>")
        self.max_iter_label.setStyleSheet("color: #0a2342; font-size: 15px;")
        self.max_iter_label.setToolTip(
            "Maximum number of iterations for fractal calculation."
        )
        self.max_iter_entry = QLineEdit()
        self.max_iter_entry.setText(str(self.max_iter))
        self.max_iter_entry.setToolTip(
            "Enter an integer (e.g., 100). Higher values increase detail but slow down rendering."
        )
        self.max_iter_entry.setAccessibleName("Max Iterations Input")
        self.max_iter_entry.setStyleSheet(
            "QLineEdit { background: #fff; border: 1.5px solid #1976d2; border-radius: 7px; padding: 7px 11px; font-size: 15px; color: #0a2342; }"
        )
        self.max_iter_entry.editingFinished.connect(self.edit_max_iter_changed)
        controls_layout.addWidget(self.max_iter_label, 3, 0)
        controls_layout.addWidget(self.max_iter_entry, 3, 1)

        self.power_label = QLabel("<b>Power:</b>")
        self.power_label.setStyleSheet("color: #0a2342; font-size: 15px;")
        self.power_label.setToolTip(
            "Exponent used in Mandelbrot/Burning Ship fractals."
        )
        self.power_entry = QLineEdit()
        self.power_entry.setText(str(self.power))
        self.power_entry.setToolTip(
            "Enter a decimal (e.g., 2.0). Only used for Mandelbrot/Burning Ship."
        )
        self.power_entry.setAccessibleName("Power Input")
        self.power_entry.setStyleSheet(
            "QLineEdit { background: #fff; border: 1.5px solid #1976d2; border-radius: 7px; padding: 7px 11px; font-size: 15px; color: #0a2342; }"
        )
        self.power_entry.editingFinished.connect(self.edit_power_changed)
        controls_layout.addWidget(self.power_label, 4, 0)
        controls_layout.addWidget(self.power_entry, 4, 1)

        self.c_real_label = QLabel("<b>Constant (c) - Real Part:</b>")
        self.c_real_label.setStyleSheet("color: #0a2342; font-size: 15px;")
        self.c_real_label.setToolTip("Real part of the Julia set constant.")
        self.c_real_entry = QLineEdit()
        self.c_real_entry.setText(str(self.c_real))
        self.c_real_entry.setToolTip(
            "Enter a decimal (e.g., -0.42). Only used for Julia fractal."
        )
        self.c_real_entry.setAccessibleName("Julia Real Input")
        self.c_real_entry.setStyleSheet(
            "QLineEdit { background: #fff; border: 1.5px solid #1976d2; border-radius: 7px; padding: 7px 11px; font-size: 15px; color: #0a2342; }"
        )
        self.c_real_entry.editingFinished.connect(self.edit_c_real_changed)
        self.c_imag_label = QLabel("<b>Constant (c) - Imaginary Part:</b>")
        self.c_imag_label.setStyleSheet("color: #0a2342; font-size: 15px;")
        self.c_imag_label.setToolTip("Imaginary part of the Julia set constant.")
        self.c_imag_entry = QLineEdit()
        self.c_imag_entry.setText(str(self.c_imag))
        self.c_imag_entry.setToolTip(
            "Enter a decimal (e.g., 0.6). Only used for Julia fractal."
        )
        self.c_imag_entry.setAccessibleName("Julia Imaginary Input")
        self.c_imag_entry.setStyleSheet(
            "QLineEdit { background: #fff; border: 1.5px solid #1976d2; border-radius: 7px; padding: 7px 11px; font-size: 15px; color: #0a2342; }"
        )
        self.c_imag_entry.editingFinished.connect(self.edit_c_imag_changed)
        controls_layout.addWidget(self.c_real_label, 5, 0)
        controls_layout.addWidget(self.c_real_entry, 5, 1)
        controls_layout.addWidget(self.c_imag_label, 6, 0)
        controls_layout.addWidget(self.c_imag_entry, 6, 1)
        self.c_real_label.setVisible(False)
        self.c_real_entry.setVisible(False)
        self.c_imag_label.setVisible(False)
        self.c_imag_entry.setVisible(False)

        # Notes/Formula area
        self.text_area = QLabel()
        self.text_area.setWordWrap(True)
        self.text_area.setTextFormat(Qt.TextFormat.RichText)
        self.text_area.setStyleSheet(
            "QLabel { background: #f7fafc; border: 1.5px solid #b5c7f7; border-radius: 10px; font-size: 15px; color: #0a2342; padding: 12px; }"
        )
        self.text_area.setText(self.get_fractal_info(self.fractal_type))
        self.text_area.setAlignment(
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft
        )
        controls_layout.addWidget(self.text_area, 3, 0, 1, 2)
        for i in range(3):
            controls_layout.setRowStretch(i, 0)
        controls_layout.setRowStretch(3, 100)
        controls_layout.setColumnStretch(0, 1)
        controls_layout.setColumnStretch(1, 1)

        # Add controls frame to the left
        controls_frame.setLayout(controls_layout)
        # Set left column to minimum width, right to maximum
        layout.addWidget(
            controls_frame, 2, 0, 2, 1, alignment=Qt.AlignmentFlag.AlignTop
        )
        # Set left column to 35% and right to 65% of width
        layout.setColumnMinimumWidth(0, 200)
        layout.setColumnStretch(0, 7)

        # Create right panel widgets before adding to layout
        self.generate_button = QPushButton("Generate Fractal")
        self.generate_button.setToolTip(
            "Click to generate the selected fractal with current parameters."
        )
        self.generate_button.setAccessibleName("Generate Fractal Button")
        self.generate_button.clicked.connect(self.generate_fractal_threaded)
        self.generate_button.setStyleSheet(
            "QPushButton {padding: 10px 18px; font-size: 16px; background: #1976d2; color: #fff; border-radius: 9px; font-weight: bold;} QPushButton:hover {background: #0a2342;}"
        )

        self.save_button = QPushButton("Save Fractal")
        self.save_button.setToolTip(
            "Save the currently displayed fractal as a PNG image."
        )
        self.save_button.setAccessibleName("Save Fractal Button")
        self.save_button.clicked.connect(self.save_fractal)
        self.save_button.setStyleSheet(
            "QPushButton {padding: 10px 18px; font-size: 16px; background: #43aa8b; color: #fff; border-radius: 9px; font-weight: bold;} QPushButton:hover {background: #277c5a;}"
        )

        self.progress = QProgressBar()
        self.progress.setStyleSheet(
            "QProgressBar { border-radius: 7px; height: 18px; font-size: 14px; color: #0a2342; background: #eaf3fa; border: 1.5px solid #b5c7f7; } QProgressBar::chunk { background: #1976d2; border-radius: 7px; }"
        )

        # Right side: Fractal display and actions
        right_frame = QFrame()
        right_frame.setStyleSheet(
            "background: #f7fafc; border-radius: 14px; border: 1.5px solid #b5c7f7; padding: 0px 0px 0px 0px;"
        )
        # Remove extra padding for max area
        right_vbox = QVBoxLayout()
        right_vbox.setContentsMargins(0, 0, 0, 0)
        right_vbox.setSpacing(10)
        right_vbox.addWidget(self.generate_button)
        self.figure, self.ax = plt.subplots(figsize=(12, 10))
        self.canvas = FigureCanvasQTAgg(self.figure)
        self.canvas.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
        )
        right_vbox.addWidget(self.canvas, stretch=1)
        right_vbox.addWidget(self.save_button)
        right_vbox.addItem(
            QSpacerItem(
                20, 20, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding
            )
        )
        right_vbox.addWidget(self.progress)
        right_frame.setLayout(right_vbox)
        layout.addWidget(right_frame, 2, 1, 2, 1)
        layout.setColumnStretch(1, 13)  # 7:13 ratio for 35%:65%
        layout.setRowStretch(2, 100)  # Maximize row for canvas
        self.fractal_tab.setLayout(layout)

    def setup_wiki_tab(self):
        """
        Set up the Fractal Box Counting tab to display wiki content with a dropdown selector.
        """

        import os
        from PyQt6.QtWidgets import (
            QComboBox,
            QTextBrowser,
            QVBoxLayout,
            QLabel,
            QFrame,
            QHBoxLayout,
        )
        from PyQt6.QtCore import Qt
        import markdown

        # Main layout for the wiki tab
        layout = QVBoxLayout()
        layout.setContentsMargins(24, 24, 24, 24)
        layout.setSpacing(16)

        # Header section

        # Header section
        header = QLabel("<b style='font-size:22px;'>üìö Fractal Workspace Wiki</b>")
        header.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        header.setStyleSheet(
            "color: #1a1a1a; padding-bottom: 4px; letter-spacing: 0.5px;"
        )
        layout.addWidget(header)

        # Optional help text
        help_text = QLabel(
            "<span style='color:#3d3d3d;'>Select a topic to learn about fractals, box counting, and their applications. Mathematical equations are rendered below.</span>"
        )
        help_text.setWordWrap(True)
        help_text.setStyleSheet(
            "font-size: 13px; padding-bottom: 8px; background: #f7f7fa; border-radius: 6px; padding: 8px 12px; color: #3d3d3d;"
        )
        layout.addWidget(help_text)

        # Dropdown section with background
        dropdown_frame = QFrame()
        dropdown_frame.setFrameShape(QFrame.Shape.StyledPanel)
        dropdown_frame.setStyleSheet(
            "background: #e9ecef; border-radius: 10px; padding: 10px 16px; border: 1px solid #d1d5db;"
        )
        dropdown_layout = QHBoxLayout()
        dropdown_layout.setContentsMargins(0, 0, 0, 0)
        dropdown_layout.setSpacing(8)

        dropdown_label = QLabel("<b>Topic:</b>")
        dropdown_label.setStyleSheet("color: #1a1a1a; font-size: 15px;")
        dropdown_layout.addWidget(dropdown_label)

        self.wiki_selector = QComboBox()
        self.wiki_selector.addItems(
            [
                "Wiki Home",
                "Fractals in Medical Imaging",
                "Box Counting Method",
                "Fractal Types and Equations",
            ]
        )
        self.wiki_selector.setToolTip("Select a topic to view detailed information.")
        self.wiki_selector.setStyleSheet(
            "QComboBox { background: #f7fafc; border: 1px solid #bfc0c0; border-radius: 6px; padding: 6px 12px; font-size: 15px; color: #1a1a1a; }"
            "QComboBox QAbstractItemView { background: #f7fafc; selection-background-color: #b5c7f7; color: #1a1a1a; }"
        )
        dropdown_layout.addWidget(self.wiki_selector)
        dropdown_frame.setLayout(dropdown_layout)
        layout.addWidget(dropdown_frame)

        # QTextBrowser for displaying HTML content
        self.wiki_viewer = QTextBrowser()
        self.wiki_viewer.setOpenExternalLinks(True)
        self.wiki_viewer.setStyleSheet(
            "QTextBrowser { "
            "  background: #f7fafc; "
            "  border: 1px solid #d1d5db; "
            "  border-radius: 12px; "
            "  font-size: 16px; "
            "  color: #181818; "
            "  padding: 28px; "
            "  selection-background-color: #b5c7f7; "
            "  line-height: 1.7em; "
            "} "
            "h1, h2, h3, h4, h5, h6 { color: #1a1a1a; margin-top: 18px; margin-bottom: 8px; } "
            "b, strong { color: #181818; } "
            "a { color: #0056b3; text-decoration: underline; } "
            "ul, ol { margin-left: 24px; } "
            "code, pre { background: #e9ecef; color: #c7254e; border-radius: 4px; padding: 2px 8px; font-family: 'Fira Mono', 'Consolas', 'Menlo', monospace; } "
        )
        layout.addWidget(self.wiki_viewer, stretch=1)

        # Load markdown files and convert to HTML
        wiki_dir = os.path.join(os.path.dirname(__file__), "wiki")
        self.wiki_files = [
            os.path.join(wiki_dir, "Home.md"),
            os.path.join(wiki_dir, "Fractals-in-Medical-Imaging.md"),
            os.path.join(wiki_dir, "Box-Counting-Method.md"),
            os.path.join(wiki_dir, "Fractal-Types-and-Equations.md"),
        ]
        self.wiki_html = []

        # Use markdown-katex extension to render LaTeX math as HTML (KaTeX)
        try:
            try:
                pass
            except ImportError:
                pass
                # Optionally log or print a warning if math rendering is not available
                # print("Warning: mdx_katex is not installed. Math rendering in the wiki will be limited.")
            katex_ext = ["mdx_katex"]
        except ImportError:
            katex_ext = []

        for md_file in self.wiki_files:
            try:
                with open(md_file, "r", encoding="utf-8") as f:
                    md_text = f.read()
                html = markdown.markdown(
                    md_text,
                    extensions=["extra", "sane_lists", "toc", "tables"] + katex_ext,
                )
                # Add KaTeX CSS for math rendering (no JS, only CSS)
                katex_css = '<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">'
                html_with_katex = f"""
                <html>
                <head>{katex_css}</head>
                <body>{html}</body>
                </html>
                """
                self.wiki_html.append(html_with_katex)
            except Exception as e:
                self.wiki_html.append(
                    f"<b>Error loading file:</b> {md_file}<br><pre>{e}</pre>"
                )

        def on_wiki_changed(idx):
            self.wiki_viewer.setHtml(self.wiki_html[idx])

        self.wiki_selector.currentIndexChanged.connect(on_wiki_changed)
        # Show the first article by default
        self.wiki_viewer.setHtml(self.wiki_html[0])

        self.wiki_tab.setLayout(layout)

    def combo_frac_type_changed(self, s):
        # Also update the text area with verbose info and formula
        if hasattr(self, "text_area"):
            self.text_area.setText(self.get_fractal_info(s))
        """
        Update parameter fields visibility based on selected fractal type.
        Args:
            s (str): Selected fractal type.
        """
        self.fractal_type = s
        fractal_type = self.fractal_type

        if fractal_type in ["Mandelbrot", "Burning Ship"]:
            self.power_label.setVisible(True)
            self.power_entry.setVisible(True)
            self.c_real_label.setVisible(False)
            self.c_real_entry.setVisible(False)
            self.c_imag_label.setVisible(False)
            self.c_imag_entry.setVisible(False)

        elif fractal_type == "Julia":
            self.power_label.setVisible(False)
            self.power_entry.setVisible(False)
            self.c_real_label.setVisible(True)
            self.c_real_entry.setVisible(True)
            self.c_imag_label.setVisible(True)
            self.c_imag_entry.setVisible(True)

        else:
            self.power_label.setVisible(False)
            self.power_entry.setVisible(False)
            self.c_real_label.setVisible(False)
            self.c_real_entry.setVisible(False)
            self.c_imag_label.setVisible(False)
            self.c_imag_entry.setVisible(False)

    def combo_resolution_changed(self, s):
        """
        Update the selected resolution.
        Args:
            s (str): Selected resolution string.
        """
        self.resolution = s

    def combo_color_scheme_changed(self, s):
        """
        Update the selected color scheme.
        Args:
            s (str): Selected color scheme.
        """
        self.color_scheme = s

    def edit_max_iter_changed(self):
        """
        Validate and update the maximum iterations parameter.
        Shows a warning if the value is not an integer.
        """
        try:
            self.max_iter = int(self.max_iter_entry.text())
        except ValueError:
            QMessageBox.warning(
                self,
                "Max Iterations Warning!",
                "The entered value must be an integer number.",
            )

    def edit_power_changed(self):
        """
        Validate and update the power parameter.
        Shows a warning if the value is not a float.
        """
        try:
            power = self.power_entry.text().replace(",", ".")
            self.power = float(power)
        except ValueError:
            QMessageBox.warning(
                self, "Power Warning!", "The entered value must be a decimal number."
            )

    def edit_c_real_changed(self):
        """
        Validate and update the real part of the Julia set constant.
        Shows a warning if the value is not a float.
        """
        try:
            c_real = self.c_real_entry.text().replace(",", ".")
            self.c_real = float(c_real)
        except ValueError:
            QMessageBox.warning(
                self,
                "Constant (c) Real Part Warning!",
                "The entered value must be a decimal number.",
            )

    def edit_c_imag_changed(self):
        """
        Validate and update the imaginary part of the Julia set constant.
        Shows a warning if the value is not a float.
        """
        try:
            c_imag = self.c_imag_entry.text().replace(",", ".")
            self.c_imag = float(c_imag)
        except ValueError:
            QMessageBox.warning(
                self,
                "Constant (c) Imaginary Part Warning!",
                "The entered value must be a decimal number.",
            )

    def generate_fractal_threaded(self):
        """
        Start fractal generation in a separate thread to keep the UI responsive.
        Handles exceptions and disables the generate button during processing.
        """
        self.queue = queue.Queue()
        try:
            threading.Thread(target=self.generate_fractal, args=(self.queue,)).start()
            time.sleep(0.1)
            self.check_queue()
        except Exception as e:
            QMessageBox.critical(
                self, "Thread Error", f"Error starting fractal generation thread: {e}"
            )

    def check_queue(self):
        """
        Check the queue for completed fractal generation and update the UI.
        Handles queue empty state and updates progress.
        """
        try:
            fractal, fractal_type, color_scheme = self.queue.get_nowait()
            self.progress.setValue(100)
            self.display_fractal(fractal, fractal_type, color_scheme)
        except queue.Empty:
            self.progress.setValue(self.progress_value)
            time.sleep(0.1)
            self.check_queue()
        except Exception as e:
            QMessageBox.critical(
                self, "Queue Error", f"Error checking fractal generation queue: {e}"
            )

    def generate_fractal(self, q):
        """
        Generate the selected fractal and put the result in the queue.
        Handles exceptions and disables the generate button during processing.
        """
        self.generate_button.setEnabled(False)
        self.progress_value = 0
        self.progress.setValue(self.progress_value)
        fractal_type = self.fractal_type
        width, height = self.get_resolution()
        max_iter = self.max_iter
        color_scheme = self.color_scheme

        try:
            fractal = None
            if fractal_type == "Mandelbrot":
                fractal = Mandelbrot(
                    width, height, -2, 1, -1.5, 1.5, max_iter, self.power
                ).generate()
            elif fractal_type == "Julia":
                c = complex(self.c_real, self.c_imag)
                fractal = Julia(width, height, -2, 2, -2, 2, max_iter, c).generate()
            elif fractal_type == "Burning Ship":
                fractal = BurningShip(
                    width, height, -2, 2, -2, 2, max_iter, self.power
                ).generate()
            elif fractal_type == "Newton":
                fractal = NewtonFractal(
                    width, height, -2, 2, -2, 2, max_iter
                ).generate()
            elif fractal_type == "Barnsley Fern":
                fractal = BarnsleyFern(width, height, max_iter).generate()
            elif fractal_type == "Sierpinski Triangle":
                fractal = SierpinskiTriangle(width, height, max_iter).generate()

            q.put((fractal, fractal_type, color_scheme))
            self.fractal = fractal
            self.color_scheme_final = color_scheme
        except Exception as e:
            QMessageBox.critical(
                self, "Fractal Generation Error", f"Error generating fractal: {e}"
            )
            self.generate_button.setEnabled(True)

    def display_fractal(self, fractal, fractal_type, color_scheme):
        """
        Display the generated fractal image on the canvas.
        Handles exceptions and ensures the UI is updated.
        """
        try:
            self.fractal = fractal
            self.fractal_type = fractal_type
            self.color_scheme_final = color_scheme
            self.ax.clear()
            if self.fractal_type == "Sierpinski Triangle":
                norm = matplotlib.colors.Normalize(vmin=0, vmax=1)
                cmap = plt.get_cmap("binary")
                extent = (0, 1, 0, 1)
            elif self.fractal_type == "Mandelbrot":
                norm = matplotlib.colors.Normalize(
                    vmin=self.fractal.min(), vmax=self.fractal.max()
                )
                cmap = plt.get_cmap(self.color_scheme_final)
                extent = (-2, 1, -1.5, 1.5)
            elif self.fractal_type == "Julia":
                norm = matplotlib.colors.Normalize(
                    vmin=self.fractal.min(), vmax=self.fractal.max()
                )
                cmap = plt.get_cmap(self.color_scheme_final)
                extent = (-2, 2, -2, 2)
            elif self.fractal_type == "Burning Ship":
                norm = matplotlib.colors.Normalize(
                    vmin=self.fractal.min(), vmax=self.fractal.max()
                )
                cmap = plt.get_cmap(self.color_scheme_final)
                extent = (-2, 2, -2, 2)
            elif self.fractal_type == "Newton":
                norm = matplotlib.colors.Normalize(
                    vmin=self.fractal.min(), vmax=self.fractal.max()
                )
                cmap = plt.get_cmap(self.color_scheme_final)
                extent = (-2, 2, -2, 2)
            elif self.fractal_type == "Barnsley Fern":
                norm = matplotlib.colors.Normalize(
                    vmin=self.fractal.min(), vmax=self.fractal.max()
                )
                cmap = plt.get_cmap(self.color_scheme_final)
                extent = (0, 8, 0, 10)
            else:
                norm = matplotlib.colors.Normalize(
                    vmin=self.fractal.min(), vmax=self.fractal.max()
                )
                cmap = plt.get_cmap(self.color_scheme_final)
                extent = (0, 1, 0, 1)
            self.ax.imshow(self.fractal, cmap=cmap, norm=norm, extent=extent)
            self.ax.set_title(f"{self.fractal_type} - {self.color_scheme_final}")
            self.canvas.draw()
        except Exception as e:
            QMessageBox.critical(
                self, "Display Error", f"Error displaying fractal: {e}"
            )
        finally:
            self.generate_button.setEnabled(True)

    def save_fractal(self):
        """
        Save the currently displayed fractal image to a PNG file.
        Handles exceptions and shows user-friendly messages.
        """
        if hasattr(self, "fractal"):
            try:
                filename = QFileDialog.getSaveFileName(
                    self,
                    caption="Save fractal in .png image",
                    directory="fractal.png",
                    filter="(*.png)",
                )
                if filename[0]:
                    cmap = plt.get_cmap(self.color_scheme_final)
                    plt.imsave(
                        filename[0],
                        self.fractal,
                        cmap=cmap,
                        origin="lower",
                        dpi=100,
                    )
                    QMessageBox.information(
                        self, "Success!", "Fractal image saved successfully."
                    )
            except Exception as e:
                QMessageBox.critical(
                    self, "Save Error", f"Error saving fractal image: {e}"
                )
        else:
            QMessageBox.warning(self, "Warning!", "No fractal data available to save.")

    def get_resolution(self):
        """
        Parse the selected resolution string and return width and height as integers.
        """
        res_text = self.resolution
        width, height = map(int, res_text.split("x"))
        return width, height

    # Code for Box Counting
    def setup_box_counter_tab(self):
        """
        Set up the Box Counter tab UI for selecting images and computing fractal dimension of ROIs.
        Allows users to load an image, set ROI size, and click to measure fractal dimension.
        """
        from PyQt6.QtWidgets import QVBoxLayout, QHBoxLayout, QFrame

        layout = QVBoxLayout()

        # Header
        header = QLabel(
            "<h2 style='color:#234; margin-bottom:0;'>Fractal Box Counter</h2>"
        )
        header.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        header.setStyleSheet(
            "background:#eaf3fa; color:#234; border-radius:10px; padding:10px 0 6px 18px; margin-bottom:8px;"
        )
        layout.addWidget(header)

        # Controls panel
        controls_panel = QFrame()
        controls_panel.setStyleSheet(
            "background:#f6fafd; border-radius:10px; padding:18px 18px 12px 18px; margin-bottom:8px;"
        )
        controls_layout = QHBoxLayout()
        controls_layout.setSpacing(18)

        # Select Image
        self.bc_select_btn = QPushButton("Select Image")
        self.bc_select_btn.setToolTip(
            "Load a grayscale image for box counting analysis."
        )
        self.bc_select_btn.setAccessibleName("Select Image Button")
        self.bc_select_btn.setStyleSheet(
            "QPushButton { font-size: 11pt; padding: 8px 18px; border-radius: 8px; background: #1976d2; color: #fff; font-weight: bold; } QPushButton:hover { background: #1565c0; }"
        )
        self.bc_select_btn.clicked.connect(self.bc_select_image)
        controls_layout.addWidget(self.bc_select_btn)

        # ROI Size
        roi_panel = QVBoxLayout()
        roi_label = QLabel("ROI Size:")
        roi_label.setToolTip("Region of Interest (ROI) size in pixels (e.g., 128).")
        roi_label.setStyleSheet("font-weight:bold; color:#234; font-size:10.5pt;")
        self.bc_roi_edit = QLineEdit()
        self.bc_roi_edit.setPlaceholderText("e.g. 128")
        self.bc_roi_edit.setToolTip(
            "Enter the ROI size in pixels. Must be a positive integer."
        )
        self.bc_roi_edit.setAccessibleName("ROI Size Input")
        self.bc_roi_edit.setStyleSheet(
            "font-size:11pt; padding:4px 8px; border-radius:6px; border:1.5px solid #7da0c4; color:#234; background:#fff;"
        )
        roi_panel.addWidget(roi_label)
        roi_panel.addWidget(self.bc_roi_edit)
        controls_layout.addLayout(roi_panel)

        # Apply ROI Size
        self.bc_start_btn = QPushButton("Apply ROI Size")
        self.bc_start_btn.setToolTip("Apply the specified ROI size for box counting.")
        self.bc_start_btn.setAccessibleName("Apply ROI Size Button")
        self.bc_start_btn.setStyleSheet(
            "QPushButton { font-size: 11pt; padding: 8px 18px; border-radius: 8px; background: #43a047; color: #fff; font-weight: bold; } QPushButton:hover { background: #388e3c; }"
        )
        self.bc_start_btn.clicked.connect(self.bc_apply_roi_size)
        controls_layout.addWidget(self.bc_start_btn)

        controls_panel.setLayout(controls_layout)
        layout.addWidget(controls_panel)

        # Status/info label
        self.bc_status = QLabel("No image loaded.")
        self.bc_status.setToolTip("Status of the loaded image and ROI selection.")
        self.bc_status.setStyleSheet(
            "font-size:11pt; color:#fff; background:#1976d2; border-radius:7px; padding:7px 16px; margin-bottom:8px; font-weight:bold;"
        )
        layout.addWidget(self.bc_status)

        # Instructions
        instructions = QLabel(
            "<b>Instructions:</b> <ul style='margin:0 0 0 18px;padding:0;font-size:10.5pt;color:#3a4a5d;'>"
            "<li>Click <b>Select Image</b> to load a grayscale or color image.</li>"
            "<li>Enter the <b>ROI Size</b> (e.g., 128) and click <b>Apply ROI Size</b>.</li>"
            "<li>Click on the image to select the top-left corner of the ROI for box counting.</li>"
            "<li>The fractal dimension will be computed and displayed for the selected region.</li>"
            "</ul>"
        )
        instructions.setWordWrap(True)
        instructions.setTextFormat(Qt.TextFormat.RichText)
        instructions.setAlignment(
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop
        )
        instructions.setStyleSheet(
            "font-size: 11pt; color: #234; background: #eaf3fa; border-radius: 8px; padding: 10px 18px; margin-bottom: 8px;"
        )
        layout.addWidget(instructions)

        # Image display area
        self.bc_image_label = ROIImageLabel(self)
        self.bc_image_label.setStyleSheet(
            "QLabel { background: #181c24; border: 2.5px solid #7da0c4; border-radius: 18px; box-shadow: 0 4px 18px #b7c7d7; }"
        )
        self.bc_image_label.setMinimumSize(480, 480)
        self.bc_image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.bc_image_label, stretch=1)

        self.box_counter_tab.setLayout(layout)

        # State
        self.bc_image = None  # Original grayscale numpy image
        self.bc_roi_size = None
        self.bc_point = None  # (x, y) top-left of last ROI
        self.bc_last_fd = None
        self.bc_last_time = None

    # ---------- Box Counter (embedded) helpers ----------
    def bc_select_image(self):
        """
        Use BoxCounterHelpers to select and load an image for box counting.
        """
        result = BoxCounterHelpers.select_image(self)
        if result is None:
            return
        img, fname = result
        self.bc_image = img
        self.bc_point = None
        self.bc_last_fd = None
        self.bc_last_time = None
        self.bc_status.setText(f"Loaded: {fname}")
        BoxCounterHelpers.update_display(self)

    def bc_apply_roi_size(self):
        """
        Use BoxCounterHelpers to set the ROI size for box counting.
        """
        roi_size = BoxCounterHelpers.apply_roi_size(self, self.bc_roi_edit.text())
        if roi_size is None:
            return
        self.bc_roi_size = roi_size
        self.bc_status.setText(
            f"ROI size set to {roi_size}. Click in image to measure."
        )
        BoxCounterHelpers.update_display(self)

    def bc_update_display(self):
        """
        Use BoxCounterHelpers to update the display for box counting.
        """
        BoxCounterHelpers.update_display(self)

    def bc_compute_roi(self, x, y):
        """
        Use BoxCounterHelpers to compute the fractal dimension for the ROI and update the display.
        """
        BoxCounterHelpers.compute_roi(self, x, y)


# ====== Box Counting code end

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    app.exec()
